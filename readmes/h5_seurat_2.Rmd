---
title: "h5_seurat_2"
output: html_document
date: "2025-02-28"
---

## Using Seurat to make CountsMatrix of scRNA-seq data

### 1. Installing packages

```{r}
#Installing packages 
install.packages("Seurat")
library(Seurat)
install.packages("SeuratObject")
library(SeuratObject)
install.packages("hdf5r")
library(hdf5r)
install.packages("rhdf5")
library(rhdf5)
```

### 2. Loading in the data (h5 files)

```{r}
#Read in scRNAseq datafile 
files <- list.files(path= 'GSE153162_RAW_No_KO/', pattern='.h5', full.names =TRUE)
print(files[1:3])
View(files)
typeof(files) #[1] character
str(files[1])

tester <- Read10X_h5(files[1])
View(tester)
print(str(tester))
```

```{r}
#Trying to find the metadata file in the h5 file
h5ls(files[1])
```

```{r}
h5read(files[1], "/mm10/genes")
```

```{r}
View(h5read(files[1], "//mm10"))

```

### 3. Creating Individual Seurat Objects

-   **Because its 23 different h5 files, its better to make 23 separate seurat objects and then merge them, rather than making them 23 different layers of one seurat object**
-   **Basically, performing downstream pre-processing on a merged Seurat object was causing problems so instead I'm going to try and apply them all on the individual 23 objects and then merge them - also more memory-efficient**

```{r}
#Viewing all 23 files 
sc_data <- lapply(files, Read10X_h5)
typeof(sc_data) #[1] list 
lapply(sc_data, dim) #[1] all 23 files have different number of rows and columns  - different number of genes across the files
print(sc_data[1])
View(sc_data[1])

```

```{r}
#Attempting to generate SeuratObject without any prior preprocessing i.e., assigning unique values to duplicated cells 

#Making Seurat Objects 
seurat_list = list() #Making empty seurat list
for (x in files){
  sc_sample <- Read10X_h5(x)
  seurat_obj <- CreateSeuratObject(counts=sc_sample, assay = "RNA", project = paste0("Sample ", x))
  seurat_obj$sample <- paste0("Sample ", x)
  seurat_list[[x]] <- seurat_obj
}

print(seurat_list)
```

### 4. Data Cleaning and Preprocessing of Individual Seurat Objects

#### a. Filtering low counts

-   **Prevents low-level exp noise from being amplified during normalization**
-   **As performed in the original paper, first create a new column that 'calculates the percentage originating from mitochondrial RNA per cell'**
-   **Then perform filtering based on the mitochondrial reads - om paper (mitochondrial reads \<7.5%, genes detected \> 500)**

```{r}

View(seurat_list[1])
names(seurat_obj)

# Check if there are any mitochondrial genes (case-sensitive)
seurat_list <- lapply(seurat_list, function(seurat_obj){
  mito_genes <- grep("^(mt-|MT-)", rownames(seurat_obj[["RNA"]]), value = TRUE)
  seurat_obj[["mito_pct"]] <- PercentageFeatureSet(seurat_obj, pattern = "^mt-") #Adding column to object metadata 
  return(seurat_obj)
})

# Print a few mitochondrial genes
mito_genes <- grep("^(mt-|MT-)", rownames(seurat_obj[["RNA"]]), value = TRUE)
head(mito_genes) #[1] "mt-Nd1"  "mt-Nd2"  "mt-Co1"  "mt-Co2"  "mt-Atp8" "mt-Atp6" 
#mitochondrial genes are denoted as mt 

head(seurat_list[[1]]@meta.data$mito_pct) #[1] 3.073198 1.811368 2.548294 3.540573 4.116694 3.832168
print(str(seurat_list[[1]])) #[Now has mito_pct]

```

```{r}
# Extract the mito_pct from all Seurat objects and combine into a single vector
mt_pct_data <- lapply(seurat_list, function(seurat_obj) {
  return(seurat_obj@meta.data$mito_pct)
})

mt_pct_combined <- unlist(mt_pct_data)

mt_pct_df <- data.frame(mito_pct = mt_pct_combined, 
                        sample = rep(names(seurat_list), sapply(mt_pct_data, length)))

# Create a violin plot using ggplot2
library(ggplot2)
ggplot(mt_pct_df, aes(x = "mito_pct.", y = mito_pct)) +
  geom_violin(fill = "violet" ) +
  labs(title = "Mitochondrial Percentage Distribution", y = "mito_pct")

```

```{r}
#Filtering reads 
seurat_list <- lapply(seurat_list, function(seurat_obj){
  seurat_obj<- subset(seurat_obj, subset= mito_pct<7.5 & nFeature_RNA > 500)
  return(seurat_obj)
})

```

#### b. Data Normalization

```{r}
seurat_list <- lapply(seurat_list, function(seurat_obj) {
  # Normalize the data
  seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize", assay = "RNA")
  return(seurat_obj)
})

```

#### c. Converting from Assay5 to Assay

##### **The Assay5 is causing problems and makes downstream preprocessing difficult so we are going to convert them first**

```{r}
slotNames(seurat_list[[1]]@assays$RNA)
```

```{r}
View(seurat_obj[1])
View(seurat_list)


#Converting 'Assay5' in each Seurat object into Assay 
seurat_list <- lapply(seurat_list, function(obj){
  
  counts_matrix <- obj[["RNA"]]$counts
  data_matrix <- obj[["RNA"]]$data
  
  new_assay <- CreateAssayObject(counts = counts_matrix)
  new_assay@data <- data_matrix
  
  obj[["RNA"]] <- new_assay
  
  return(obj)

  
})


str(seurat_list) #[1] $RNA:Formal class 'Assay'
```

### 5. Merging Seurat Objects

```{r}

head(seurat_list[[1]]@meta.data) #has mito.pct
str(seurat_list[1]) #can see scale data 
head(seurat_list[[1]]@assays$RNA@data)
print(seurat_list[[1]])

#Get sample IDs for each Seurat Object e.g., GSE..._RAW
for (i in seq_along(seurat_list)){
  seurat_list[[i]]@project.name <- names(seurat_list) [i]
}
print(seurat_list[[1]]@project.name) #[1] "GSE153164_RAW//GSM4635072_E11_5_filtered_gene_bc_matrices_h5.h5"

#Merge
seurat_merged <- Reduce(function(x,y){
  merge(x,y, add.cell.ids = c(x@project.name, y@project.name))
}, seurat_list)


View(seurat_merged)
```

#### a. Using FindVariableFeatures to find outliers

-   From paper, "[...] scaled expression values and identified the 3,000 most variable genes with `FindVariableFeatures(selection.method - "vst", nfeatures = 3000)`

```{r}
seurat_merged <- FindVariableFeatures(seurat_merged, selection.method = "vst", nfeatures = 3000, assay = "RNA", verbose = 1)
top10 <- head(VariableFeatures(seurat_merged), 10) #[1] Finds top 10 most highly variable genes 
print(top10) #[1] "Hba-a1"  "Hba-x"   "Hbb-y"   "Hba-a2"  "Hbb-bt"  "Hbb-bs"  "Hbb-bh1" "Cldn5"   "Sst"     "Igfbp7" 


# Alternative approach to show only top features
hvf_data <- seurat_merged[["RNA"]]@meta.features
hvf_data <- hvf_data[VariableFeatures(seurat_merged),]
hvf_data$gene <- rownames(hvf_data)

# Sort by variance
hvf_data <- hvf_data[order(hvf_data$vst.variance.standardized, decreasing = TRUE),]

# Pick top 1000 for plotting
plot_data <- head(hvf_data, 1000)

# Plot with ggplot2
library(ggplot2)
library(ggrepel)
p <- ggplot(plot_data, aes(x = vst.mean, y = vst.variance.standardized)) +
  geom_point(size = 0.5, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Top 1000 Variable Features")

# Add labels for top 10
p + geom_point(data = plot_data[1:10,], color = "violet", size = 2) +
  geom_text_repel(data = plot_data[1:10,], aes(label = gene), color = "skyblue4")

```

#### **b.** Scaling using ScaleData

```{r}
seurat_merged <- ScaleData(seurat_merged,  vars.to.regress = c("nCount_RNA", "nFeature_RNA", "mito_pct"), do.center = TRUE, do.scale = TRUE, verbose =1 )
View(seurat_merged)
str(seurat_merged)
print(head(seurat_merged))
```

## **Mapping Cell ID's to Cell Types using metaData_scDevSC**

#### **Reading in txt file from Single Cell Portal for mouse scRNA data**

```{r}

metaData_scDevSC <- read.delim("metaData_scDevSC.txt", header = TRUE, check.names = TRUE)
View(metaData_scDevSC)

metaData_scDevSC <- metaData_scDevSC[-1,] #Remove the first column

head(seurat_merged)
print(row.names(seurat_merged@meta.data)) #The rownames have a lot of 'SeuratProject' and other unnecessary names included which do not map with the cell ID's found in the metadata file 
```

#### **Cleaning up Seurat meta.data rownames**

```{r}
rownames(seurat_merged@meta.data) <- gsub("SeuratProject_", "", rownames(seurat_merged@meta.data))
print(rownames(seurat_merged@meta.data))

#Going to restructure the column names to fit those found in the 'NAME' column in metaData
rownames(seurat_merged@meta.data) <- gsub("filtered.*_", "", rownames(seurat_merged@meta.data))
print(rownames(seurat_merged@meta.data))
#Now looks like this: [2] "GSE153164_RAW..GSM4635072_E11_5_AAACCTGAGGACGAAA.1"

print((grep("[GSE.*_RAW]", print(rownames(seurat_merged@meta.data)))))
rownames(seurat_merged@meta.data) <- gsub("GSE.*_RAW_No_KO", "", rownames(seurat_merged@meta.data))
print(rownames(seurat_merged@meta.data))
#Now looks like this: [2] "..GSM4635072_E11_5_AAACCTGAGGACGAAA.1"

#Removing the ..GSM bit 
rownames(seurat_merged@meta.data) <- gsub("//GSM[0-9]+_", "", rownames(seurat_merged@meta.data))
print(rownames(seurat_merged@meta.data)) #[1] "E11_5_AAACCTGAGGACGAAA.1" - finally somewhat matches the ones seen in the 'NAME' column in the metaData file 

#Removing the '.1' at the end
rownames(seurat_merged@meta.data) <- gsub("-1$", "", rownames(seurat_merged@meta.data))

```

#### **Cleaning up the metadata file to match the Cell ID in the Seurat**

```{r}
#Removing the 'v1' in the 'NAME' entries in the metaData_scDevSC
v1_NAME <- (subset(metaData_scDevSC, grepl("v1", metaData_scDevSC$NAME)))
head(v1_NAME)
dim(v1_NAME) #[1] there are 1495 entries 

metaData_scDevSC$NAME <- gsub("v1_", "", metaData_scDevSC$NAME)
View(metaData_scDevSC)
print(head(metaData_scDevSC)) #[1] E10_AAACCTGAGGGTCTCC-1 - now the v1 and the extra _ is removed


#Removing the "-1 bit to match those in OMIM_dat
metaData_scDevSC$NAME <- gsub("-1", "", metaData_scDevSC$NAME)
print(head(metaData_scDevSC))

print(head(metaData_scDevSC))


missing_ids <- setdiff(rownames(seurat_merged@meta.data), metaData_scDevSC$NAME)
print(missing_ids) #Seeing how many of the RAW seurat_merged cells don't have a match 
print(length(missing_ids)) #17,987 missing 
```

#### **Mapping Cell ID to corresponding Cell Type**

```{r}

library(dplyr)

cell_ids <- rownames(seurat_merged@meta.data) #81,435 cell IDs in total in the seurat object
temp_df <- as.data.frame(cell_ids)
colnames(temp_df) <- "cell_ids"
print(temp_df)

metaData_scDevSC <- as.data.frame(metaData_scDevSC)
print(colnames(metaData_scDevSC)[1])
colnames(metaData_scDevSC)[1] <- "cell_ids"
typeof(metaData_scDevSC)

View((intersect(cell_ids, metaData_scDevSC$cell_ids))) #63448 matches 
matching_ids <- intersect(cell_ids, metaData_scDevSC$cell_ids)

temp_df <- left_join(temp_df, metaData_scDevSC, by = "cell_ids")
View(temp_df)

#It has joined the metadata to the temp_df file but its still showing 81, 435 entires - basically its kept in ALL cell_ids even those that don't have a corresponding entry in the metadata file and just fills those with NA's 

(temp_df[,1:28])

cleaned_temp_df <- subset(temp_df, (!is.na(temp_df[,2])))
View(cleaned_temp_df) #Now has 63,448 entries - MATCHING ONES ONLY



```

#### **Finally assigning it to the seurat_merged object**

```{r}
#Just using temp_df as it has the same number of cell IDs as the seurat object 

seurat_merged@meta.data[["New_cellType"]] <- NULL

View(temp_df)
print(DefaultAssay(seurat_merged))
cell_type_data <- temp_df$New_cellType
names(cell_type_data) <- temp_df$cell_ids
print(names(cell_type_data))

existing_cells <- intersect(names(cell_type_data), colnames(seurat_merged))
print(existing_cells)
cell_type_data <- cell_type_data[existing_cells]


seurat_merged <- AddMetaData(
  object = seurat_merged,
  metadata = cell_type_data,
  col.name = "New_cellType"
)


#Alternative method - Creating new section in meta.data for cell type - #seurat_merged@meta.data$New_cellType <- temp_df$New_cellType
#seurat_merged now has a cell type section in neta.data

print(head(seurat_merged))


print(str(seurat_merged@meta.data$New_cellType))
print(str(seurat_merged@meta.data))
View(seurat_merged@meta.data)
print(str(seurat_merged@assays$RNA@data))

print(colnames(seurat_merged@assays$RNA)) #Need to change the names to match the naming in the meta.data 
print(rownames(seurat_merged@meta.data))
colnames(seurat_merged@assays$RNA) <- rownames(seurat_merged@meta.data)

#Still getting an error when trying to RunPCA about active.idents so nede to change the names
#checking current active.indents
head(Idents(seurat_merged)) #Still the same naming as the original

#Update active.idents
Idents(seurat_merged) <- factor(rep("defualt", ncol(seurat_merged)))
names(Idents(seurat_merged)) <- colnames(seurat_merged)

new_idents <- Idents(seurat_merged)
levels(new_idents) <- "default" #I spelt it wrong initially 
Idents(seurat_merged) <- new_idents




```

## Dimensional Reduction 

### Elbow Plot

```{r}
######################## Do this bit 
```

### **Running PCA**

```{r}
  seurat_merged <- RunPCA(seurat_merged,
                          features = VariableFeatures(seurat_merged),
                          verbose =TRUE,
                          npcs =50)
```

```{r}
str(seurat_merged@reductions$pca)
pca_plot<- DimPlot(seurat_merged, reduction ="pca", raster = FALSE, group.by = "New_cellType", pt.size=0.3, label=FALSE, repel=FALSE)+ labs(title = "PCA Plot of Merged Seurat Object")+ theme_minimal() + theme(legend.position = "bottom") +theme(axis.text=element_text(size=9), legend.text = element_text(size=4))
#Use +NoLegend for no legend + label = TRUE

print(pca_plot)

ggsave("PCA_PLOT_with_NA.png", plot = pca_plot, width = 12, height=10)
```

### Running ElbowPlot Post-PCA - Determine dimensions

```{r}
ElbowPlot(seurat_merged, ndims = 50, reduction = "pca")
```

**Around PCA 25 to 30 captures the majority variance**

```{r}
seurat_merged <- FindNeighbors(seurat_merged, dims = 1:25)
seurat_merged <- FindClusters(seurat_merged, resolution = 0.5)
seurat_merged <- RunUMAP(seurat_merged, dim=1:25) 
```

```{r}
umap_plot <- DimPlot(seurat_merged, reduction = "umap", label = FALSE, group.by = "New_cellType")
print(umap_plot)
ggsave("umap_WITH_NA.png", plot = umap_plot, width = 12, height=10)

```

#### Cleaning the Erroneous Cell Types

```{r}
missing_cell_types <- (is.na(seurat_merged@meta.data$New_cellType))
print(length(subset(missing_cell_types, missing_cell_types=="TRUE"))) #17987 have NA's as a cell type 

## Trying to create a subset again
cells_with_type <- rownames(seurat_merged@meta.data)[!missing_cell_types]
seurat_subset <- subset(seurat_merged, cells = cells_with_type)

#Checking that NA's have been removed 
table(is.na(seurat_subset@meta.data$New_cellType)) #[1] FALSE
print(length(seurat_subset@meta.data$New_cellType)) #63448 which is how many we had without the NA

##Remove unnecessary cell types (e.g., Doublet, Low counts)
print(unique(seurat_subset@meta.data$New_cellType))
unnecessary_cell_types <- seurat_subset@meta.data$New_cellType == "Doublet" | seurat_subset@meta.data$New_cellType == "Low quality cells"
#Doing sum shows that there are 1543 cells that are either doublet or low quality cells 
useful_cell_types <- rownames(seurat_subset@meta.data)[!unnecessary_cell_types] #[1] Length = 61,905 cells 


seurat_subset_cleaned = subset(seurat_subset, cells = useful_cell_types)
View(seurat_subset_cleaned)

DefaultAssay(seurat_subset_cleaned) #[1] Ensuring its still RNA

```

### Plotting UMAP of Cleaned Seurat

```{r}
umap_plot <- DimPlot(seurat_subset_cleaned, reduction = "umap", label = FALSE, group.by = "New_cellType")
print(umap_plot)
ggsave("umap_WITHOUT_NA_AND_CLEANED.png", plot = umap_plot, width = 12, height=10)
```

```{r}
VlnPlot(seurat_subset_cleaned, features = ("Nfix"), group.by = "New_cellType") +theme(legend.position = "none")

```

```{r}

VlnPlot(seurat_subset_cleaned, features = c("Nfia", "Nfix"), group.by = "New_cellType") +theme(legend.position = "none")

VlnPlot(seurat_subset_cleaned, features = ("Plag1"), group.by = "New_cellType") +theme(legend.position = "none")

```

\#####**Do one to compare exp levels of NFIX and the top10 DEGs**

## **Extracting Expression Data from OMIM_dat**

```{r}
#Loading in dataset
OMIM_dat <- read.delim("OMIM_Databases_Gene_Map_Queries/cleaned OMIM_data_macro.tsv", sep="\t", na="NA")
View(OMIM_dat)
print(rownames(seurat_subset_cleaned))
extracting_genes <- intersect(rownames(seurat_subset_cleaned), OMIM_dat$Mouse.Gene..from.MGI.) #Don't need to convert anything - we had a whole column for it - 175 genes
View(extracting_genes)
print(extracting_genes)
```

## Initial Downstream Analysis and Data Visualization of Macrocephaly Genes 

### **Plotting Heatmap of macrocephaly gene expression in each cell type**

#### AverageExpression vs AggregateExpression

```{r}

print(intersect(extracting_genes, rownames(seurat_subset_cleaned)))
avg_exp <- AverageExpression(
  seurat_subset_cleaned, features = extracting_genes, group.by = "New_cellType", slot = "data"
)

avg_exp_mat <- as.matrix(avg_exp$RNA)
dim(avg_exp_mat) #[1] 175 24


#Apply the z_score normalization function to the genes (rows)
z_avg_exp <- t(apply(avg_exp_mat, 1, function(x) (x-mean(x))/sd(x))) ##Makes sure the data is reformatted back to genes as rows 

#Used to check if z-score has been correctly calculated 
print(mean(z_avg_exp[1,])) #[1] 1.387779e-17- Close to zero 
print(mean(z_avg_exp[,1])) #[1] NaN

#Doing final check that the z-score normalization was ran correctly 
sd_row <- apply(z_avg_exp, 1, sd) #All have an SD of 1 
mean_row <- apply(z_avg_exp,1, mean) #All have a mean value clos
mean_col <- apply(z_avg_exp, 2, mean) #All NaN for Cell Types - SHOULD BE 


#Checking for any non-variance genes or NaN values BEFORE z-score normalization
error_genes <- apply(z_avg_exp, 1, function (x){
  #Check for NAs
  any(is.na(x)) ||
  
  #Check for infinite vals
  any(is.infinite(x)) ||
  
  #Check for zero SD (Non-var)
  sd(x, na.rm = TRUE) == 0
})

z_avg_exp_filtered <- z_avg_exp[!error_genes,] #Filter out genes that are flagged in the function
print(dim(z_avg_exp_filtered))

############ Plotting z_score_normalized graphs 

########## Graph #1 using Pretty Heatmap

install.packages("pheatmap")
library(pheatmap)
library(RColorBrewer)


avg_exp_z_heatmap <- pheatmap(z_avg_exp_filtered, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 8, fontsize_col = 8, angle_col = 45, raster = TRUE, annotation_legend_param = list(title = "Z-score Normalization"),filename = "avg_exp_z_score_macro_pheatmap.png")

print(avg_exp_z_heatmap)


###TRY AND MAKE IT WORK TO INCLUDE A LABEL FOR THE COLOUR BAR 

library(reshape2)
library(ggplot2)

# Assuming z_agg_exp_filtered is a matrix
df <- melt(z_avg_exp_filtered)
names(df) <- c("Row", "Column", "Value")

# Create a ggplot heatmap
p <- ggplot(df, aes(x = Column, y = Row, fill = Value)) +
  geom_tile() +
  scale_fill_gradientn(colors = colorRampPalette(brewer.pal(5, "RdPu"))(100),
                      name = "Z-score\nNormalization") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8)) +
  coord_fixed()

# Save the plot
ggsave("avg_exp_z_score_macro_ggplot.png", p, width = 30, height = 20, units = "in", dpi = 100)

test_color <- colorRampPalette(brewer.pal(5,"RdPu"))(100)
print(test_color)
```

**As of v5, Seurat recommends using AggregateExpression over AverageExpression**

```{r}

intersect(extracting_genes, rownames(seurat_subset))

##Altnernative method using AggregateExpression
agg_exp <- AggregateExpression(
  seurat_subset_cleaned, features = extracting_genes, group.by = "New_cellType", slot = "data"
) #Seurat recommended using AggregateExpression

agg_exp_mat <- as.matrix(agg_exp$RNA)
dim(agg_exp_mat)

#Apply the z_score normalization function to the genes (rows)
z_agg_exp <- t(apply(agg_exp_mat, 1, function(x) (x-mean(x))/sd(x)))

#Used to check if z-score has been correctly calculated 
print(mean(z_agg_exp[1,])) #[1] -2.659909e-17 - Close to zero 
print(mean(z_agg_exp[,1])) #[1] NaN

#Doing final check that the z-score normalization was ran correctly 
sd_row <- apply(z_agg_exp, 1, sd) #All have an SD of 1 
mean_row <- apply(z_agg_exp,1, mean) #All have a mean value clos
mean_col <- apply(z_agg_exp, 2, mean) #All NaN for Cell Types - SHOULD BE 


#Checking for any non-variance genes or NaN values BEFORE z-score normalization
error_genes <- apply(z_agg_exp, 1, function (x){
  #Check for NAs
  any(is.na(x)) ||
  
  #Check for infinite vals
  any(is.infinite(x)) ||
  
  #Check for zero SD (Non-var)
  sd(x, na.rm = TRUE) == 0
})

z_agg_exp_filtered <- z_agg_exp[!error_genes,] #Filter out genes that are flagged in the function
print(dim(z_agg_exp_filtered))


install.packages("pheatmap")
library(pheatmap)
library(RColorBrewer)

agg_exp_z_heatmap <- pheatmap(z_agg_exp_filtered, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 8, fontsize_col = 8, angle_col = 45, raster = TRUE, annotation_legend_param = list(title = "Z-score Normalization"),filename = "agg_exp_z_score_macro_pheatmap.png")

print(agg_exp_z_heatmap)
View()


###TRY AND MAKE IT WORK TO INCLUDE A LABEL FOR THE COLOUR BAR 

library(reshape2)
library(ggplot2)

# Assuming z_agg_exp_filtered is a matrix
df <- melt(z_agg_exp_filtered)
names(df) <- c("Row", "Column", "Value")

# Create a ggplot heatmap
p <- ggplot(df, aes(x = Column, y = Row, fill = Value)) +
  geom_tile() +
  scale_fill_gradientn(colors = colorRampPalette(brewer.pal(5, "RdPu"))(100),
                      name = "Z-score\nNormalization") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8)) +
  coord_fixed()

# Save the plot
ggsave("cleaned_macrocephaly_z_score_ggplot.png", p, width = 30, height = 20, units = "in", dpi = 100)

test_color <- colorRampPalette(brewer.pal(5,"RdPu"))(100)
print(test_color)


```

##### Confirming which Heatmap is correct by using median expression of each gene across all cell types and then performing z-score normalization

-   Need to use MAD (Median Absolute Deviation) -\> (x - median(x))/ MAD

```{r}

gene_exp <- GetAssayData(seurat_subset_cleaned, assay = "RNA", slot = "data")#Pulling out the normalized 'data' slot/layer 
gene_exp_df <- as.data.frame(gene_exp)
gene_exp_macro <- subset(gene_exp_df, rownames(gene_exp_df) %in% extracting_genes) #subsetting to include data of only macrocephaly gene

View(gene_exp_macro)

#Extracting cell type information from meta.data 
cell_types <- seurat_subset_cleaned@meta.data$New_cellType
names(cell_types) <- colnames(seurat_subset_cleaned)

unique_cell_types <- unique(cell_types)
genes_by_cell_types <- matrix(0, 
                              nrow = nrow(gene_exp_macro), 
                              ncol = length(unique_cell_types),
                              dimnames = list(rownames(gene_exp_macro), unique_cell_types))

#Calculating median expression for each gene in EACH cell type 
for (cell_type in unique_cell_types) {
  cells_of_type <- names(cell_types)[cell_types == cell_type]
  
  #Calculate median expression for each gene in this cell type 
  genes_by_cell_types[, cell_type] <- apply(gene_exp_macro[, cells_of_type, drop = FALSE], 1, median, na.rm = TRUE)
}

#Conver to dataframe 
med_exp_gene_in_cell_type_df <- as.data.frame(genes_by_cell_types)

View(head(med_exp_gene_in_cell_type_df))


######## Try Plotting median expression as it is without the z-score normalization
library(ggplot2)
library(reshape2)

# Convert dataframe to long format
long_df <- melt(as.matrix(med_exp_gene_in_cell_type_df))

# Create plot
median_heatmap <- ggplot(long_df, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile() +
  scale_fill_gradientn(colors = colorRampPalette(brewer.pal(5, "RdPu"))(100),
                      name = "Z-score\nNormalization") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8)) +
  coord_fixed()

ggsave("median_pre_normalization.png", median_heatmap, width = 30, height = 30)

#Performing z-score normalization

########### Approach 1 
z_score_med_exp <- t(apply(med_exp_gene_in_cell_type_df, 1, function(x) (x-mean(x))/sd(x)))

########### Approach 2 
library(matrixStats)
gene_means <- rowMeans(med_exp_gene_in_cell_type_df, na.rm = TRUE)
gene_sds <- rowSds(as.matrix(med_exp_gene_in_cell_type_df), na.rm = TRUE)

z_score_df <- sweep(med_exp_gene_in_cell_type_df, 1, gene_means, "-")
z_score_df <- sweep(z_score_df, 1, gene_sds, "/")


########### Approach 3
avg_median_per_gene <- rowMeans(med_exp_gene_in_cell_type_df, na.rm = TRUE)
sd_median_per_gene <- apply(med_exp_gene_in_cell_type_df, 1, sd, na.rm = TRUE)

z_score_df_2 <- med_exp_gene_in_cell_type_df

for (i in 1:nrow(z_score_df_2)) {
  if (is.na(sd_median_per_gene[i]) || sd_median_per_gene[i] == 0) {
    z_score_df_2[i, ] <- 0 
  } else {
    z_score_df_2[i,] <- (med_exp_gene_in_cell_type_df[i,] - avg_median_per_gene[i]) / sd_median_per_gene[i]
  }
}

########## Appraoch 4 - Using MAD 
median_mad_normalize <- function(df) {
  normalize_df <- df #Create empty dataframe 
  
  for (gene in rownames(df)) {
    values <- as.numeric(df[gene, ])
    
    gene_median <- median(values, na.rm = TRUE)
    gene_MAD <- mad(values, na.rm = TRUE, constant = 1)
    
    if(gene_MAD == 0) {
      normalize_df[gene, ] <- 0
    } else {
      normalize_df[gene, ] <- (values - gene_median) / gene_MAD
    }
  }
  
  return(normalize_df)
} 

z_score_MAD_df <- median_mad_normalize(med_exp_gene_in_cell_type_df)

#Final Checks and removing non-zero variance values
#Used to check if z-score has been correctly calculated 
print(mean(z_score_med_exp[1,])) #[1] Is returning an NA - Need to check why 
print(mean(z_score_med_exp[,1])) #[1] NaN

#Doing final check that the z-score normalization was ran correctly 
sd_row <- apply(z_score_med_exp, 1, sd) #Either returning an NA or 1 
mean_row <- apply(z_score_MAD_df,1, mean) #Either returning an NA or a value close to zero 
mean_col <- apply(z_score_df, 2, mean) #All NaN for Cell Types - SHOULD BE 


#Checking for any non-variance genes or NaN values AFTER z-score normalization
error_genes <- apply(z_score_med_exp, 1, function (x){
  #Check for NAs
  any(is.na(x)) ||
  
  #Check for infinite vals
  any(is.infinite(x)) ||
  
  #Check for zero SD (Non-var)
  sd(x, na.rm = TRUE) == 0
})

z_score_med_filtered <- z_score_med_exp[!error_genes, ]

z_score_df_filtered <- z_score_df[!error_genes,] #Filter out genes that are flagged in the function
print(dim(z_score_df_filtered))

z_score_df_2_filtered <- z_score_df_2[!error_genes, ]


z_score_med_exp_heatmap <- pheatmap(z_score_med_filtered, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 8, fontsize_col = 8, angle_col = 45, raster = TRUE, annotation_legend_param = list(title = "Z-score Normalization"),filename = "median_exp_z_score_macro_pheatmap_manual.png")
```

### **Finding differentially expressed cluster biomarkers (DEGs)** 

**Can use the FindMarkers functions in Seurat and do it for all clusters i.e., all cell types**

```{r}
install.packages("BiocManager")
library(BiocManager)
BiocManager::install("DESeq2")
library(DESeq2) ##This isn't working for some reason 

#For more efficient wilcox DEA - suggested by devs
install.packages('devtools')      ##NEED TO INSTALL 
library('devtools')
devtools::install_github("immunogenomics/presto")

DefaultAssay(seurat_subset_cleaned_2)

intersect(rownames(seurat_subset_cleaned_2), extracting_genes) #All 175 macrocephaly genes have a counts matrix in the seurat obj

find_DEGs <- FindAllMarkers(seurat_subset_cleaned, group.by = "New_cellType", logfc.threshold = 0.25, test.use = "wilcox", slot = "data", verbose = TRUE, random.seed = 42) #USE DESeq2 so slot is set to counts 
#Performed on z-score data 
#Need to check if I need to run Bonferroni correction - Yes 
#Also might need to filter the number of clusters - have some clusters that we don't want to include e.g., doublet, low count etc.... should probably still include all other ones as we don't want to look biased towards early neuronal cells 
head(find_DEGs)

##### More refined DEG and clustering - Perform on groups of cell types - Need to ask which cell types to keep/cluster with

```

##### Saving things just to save time and to be on the safe side

```{r}
#Saving DEG file
write.csv(find_DEGs, "FindAllMarkers_DEG.csv")

```

```{r}
#Saving Seurat Object
install.packages("qs")
library(qs)

qs::qsave(seurat_subset_cleaned, "seurat_subset_cleaned.qs")
```

## Looking into DEGs and Performing Downstream Analysis

```{r}
#Loading in the previous files 
find_DEGs <- read.csv("FindAllMarkers_DEG.csv")
print(head(find_DEGs))

seurat_subset_cleaned <- qread("seurat_subset_cleaned.qs")
View(seurat_subset_cleaned)
```

```{r}
test_DEG_Plot <- FeaturePlot(seurat_subset_cleaned, features = extracting_genes)
print(test_DEG_Plot)
ggsave("Test_DEG_UMAP_Plot.png", test_DEG_Plot, height = 12, width = 12)
ggsave("All_data_DEG_test.png", test_DEG_Plot)

```

### Identifying which genes are up + downregulated

**NB: Positive avg_log2FC values means upregulated and vice versa**

```{r}
library(dplyr)
library(ggplot2)
upreg_markers <- find_DEGs[find_DEGs$avg_log2FC>0 & find_DEGs$p_val_adj<0.05, ]
downreg_markers <- find_DEGs[find_DEGs$avg_log2FC<0 & find_DEGs$p_val_adj<0.05, ]

upreg_markers <- as.data.frame(upreg_markers)
downreg_markers <- as.data.frame(downreg_markers)

#Work on fixing this bar plot so see the number of upreg genes per celltype (also do one for Cell_ID to Cell Type)

#Generating a basic bar plot to visualize number of upregulated genes in each cell type (cluster)
upreg_bar_plot <- ggplot(upreg_markers, aes(x=cluster, y=sum(gene))) + geom_bar(stat = "identity") + coord_flip() + labs(x= "Cell Type Cluster", y="Number of Genes") #Fix it to make it gene counts 

print(upreg_bar_plot)
ggsave("upreg_bar_chart_test.png", upreg_bar_plot)


### Seeing top 20 upregulated markers in each cell type
top_upreg_markers_by_cluster <- upreg_markers %>%
  top_n(n = 20, wt = avg_log2FC) %>%
  pull(gene)


upreg_plot <- FeaturePlot(seurat_subset_cleaned, features = top_upreg_markers_by_cluster, reduction = "umap", ncol = 4, pt.size = 1.5, order = TRUE)
print(upreg_plot)
ggsave("top_20_upreg_markers_umap.png", upreg_plot, width = 20, height = 25)

upreg_dotplot <- DotPlot(seurat_subset_cleaned, features = top_upreg_markers_by_cluster, group.by = "New_cellType") + coord_flip() + labs(x = "Genes", y = "Cell Type")
ggsave("top_20_upreg_markers_dotplot.png", upreg_dotplot, width = 30, height = 15, bg = "white")




##### Now to check top upregulated macrocephaly genes 
macro_upreg_markers <- intersect(extracting_genes, upreg_markers$gene)
print(length(macro_upreg_markers)) #161 of 175 macro genes were found to be differentially upregulated

macro_upreg_markers <- subset(upreg_markers, upreg_markers$gene %in% macro_upreg_markers)
View(macro_upreg_markers)
print(length(unique(macro_upreg_markers$gene))) #[1] 161 

top_upreg_macro_markers_by_cluster <- macro_upreg_markers %>%
  arrange(desc(avg_log2FC)) %>% #Previously used top_n but that doesn't handle duplicates very well - was getting an error about duplicates later on when trying to plot the dotplot 
  distinct(gene, .keep_all = TRUE) %>%
  slice_head(n = 20) %>%
  pull(gene)

top_upreg_macro_markers_with_data <- macro_upreg_markers %>%
  arrange(desc(avg_log2FC)) %>%
  distinct(gene, .keep_all = TRUE) %>%
  slice_head(n=20) #Not just gene names as a character variable which is what is stored when you use pull(gene)
  
upreg_macro_plot <- FeaturePlot(seurat_subset_cleaned, features = top_upreg_macro_markers_by_cluster, reduction = "umap", ncol = 4, pt.size = 1.5, order = TRUE)
print(upreg_plot)
ggsave("top_20_upreg_macro_markers_umap_without_duplicates.png", upreg_macro_plot, width = 20, height = 25)

duplicated_top_upreg_macro_markers <- subset(top_upreg_macro_markers_by_cluster, duplicated(top_upreg_macro_markers_by_cluster))
print(duplicated_top_upreg_macro_markers)

upreg_dotplot <- DotPlot(seurat_subset_cleaned, features = top_upreg_macro_markers_with_data, group.by = "New_cellType") + coord_flip() + labs(x = "Genes", y = "Cell Type") + scale_color_gradient(low = "lightgrey", mid = "skyblue", high = "navy", midpoint = median(top_upreg_macro_markers_with_data$avg_log2FC))
ggsave("top_20_upreg_macro_markers_dotplot_without_duplicates.png", upreg_dotplot, width = 30, height = 15, bg = "white")

```

### Gene Enrichment Analysis

#### Using Fisher's Exact Test

##### 1. Upregulated Macrocephaly Genes in Apical Progenitors

```{r}
## Testing for significance of upregulated genes using adj_p_value 

#Ultimately want to confirm if the proportion of upregulated macrocephaly DEGs is significantly more in Apical Progenitors compared to the overall DEGs dataset 
non_macro_upreg_markers <- upreg_markers[!upreg_markers$gene %in% macro_upreg_markers$gene, ]
View(non_macro_upreg_markers)

#1. Making a Contingency Table
n1 <- sum(macro_upreg_markers$cluster == "Apical progenitors") #[1] 53 
n2 <- sum(non_macro_upreg_markers$cluster == "Apical progenitors") #[1] 4347

#Can chck thats all the upregulated markers in Apical progenitors doing:
print(sum(upreg_markers$cluster == "Apical progenitors")) #[1] 4400 - which is the total if you add up n1 + n2 => its correct 

print(length(unique(rownames(seurat_subset_cleaned)))) #[1] 27,998

n3 <- (175-53) #[1] 122
n4 <- (27998-(122+53+4347)) #[1] 23476
      
    
contingency_table <- matrix(
  c(n1,n2,n3,n4), nrow =2)

fisher_test <- fisher.test(contingency_table, alternative = "greater")
fisher_two_tailed <- fisher.test(contingency_table, alternative = "two.sided")

```

##### 2. Creating a For Loop to save time - Checking across all Cell Types

Running both one-tailed and two-tailed. With two-tailed we can see if any macrocephaly genes are significantly depleted in specific cell types

```{r}
#All cell types 
cell_types <- unique(upreg_markers$cluster)

#Total number of genes that were tested 
total_genes <- length(unique(rownames(seurat_subset_cleaned)))

#Create a results table 
fishers_results_table <- data.frame(
  New_cellType = character(),
  odds_ratio = numeric(),
  p_val_one_sided <- numeric(),
  p_val_two_sided <- numeric(),
  stringsAsFactors = FALSE
)


for (cell_type in cell_types) {
  n1 <- sum(macro_upreg_markers$cluster == cell_type)
  n2 <- sum(non_macro_upreg_markers$cluster == cell_type)
  
  #To check that it has been calculated correctly 
  total_upreg_in_cell_type <- sum(upreg_markers$cluster == cell_type)
  if (n1+n2 != total_upreg_in_cell_type) {
    warning(paste("Calculation mismatch for ", cell_type))
  } else {
    paste("Correctly calculated for ", cell_type, "\n")
  }
  
  n3 <- (175 - n1)
  n4 <- (27998 - (n1 + n2 + n3))
  
  contingency_table <- matrix(
  c(n1,n2,n3,n4), nrow =2)
  
  fisher_one_tailed <- fisher.test(contingency_table, alternative = "greater")
  fisher_two_tailed <- fisher.test(contingency_table, alternative = "two.sided")
  
  fishers_results_table <- rbind(fishers_results_table, data.frame(
    New_cellType = cell_type,
    odds_ratio <- fisher_one_tailed$estimate,
    p_val_one_sided = fisher_one_tailed$p.value,
    p_val_two_sided = fisher_two_tailed$p.value
  ))
  
  cat("Processed:", cell_type, "- Odds Ratio:", round(fisher_test$estimate, 2), 
      "- P-value:", format.pval(fisher_test$p.value, digits = 3), "\n")
}

```

```{r}
head(fishers_results_table)
```

##### Saving the Fisher Test Result Table

```{r}
write.csv(fishers_results_table, "Fisher's_One_and_Two_Tailed_Results.csv", row.names = FALSE)
```

### Fold Enrichment Analysis

```{r}
fishers_results_table <- read.csv("Fisher's_One_and_Two_Tailed_Results.csv")
#Performing log transformation (Log2) - i.e, up or down, for easier visualization especially because we are dealing with really small values
#Adding a log2(odds_ratio) column to the results table 
fishers_results_table$log2_odds_ratio <- log2(fishers_results_table$odds_ratio....fisher_one_tailed.estimate)



#Plotting a Heatmap 
fold_enrichment_heatmap <- ggplot(fishers_results_table) + geom_tile(aes(x= New_cellType, y = factor(1), fill = log2_odds_ratio)) +  scale_fill_gradientn(colors = colorRampPalette(brewer.pal(5, "RdPu"))(100),
                      name = "Fold Enrichment") + theme_minimal()

ggsave("fold_enrichment_heatmap_ggplot.png", fold_enrichment_heatmap, bg = "white", height = 15, width = 20)

results_table$odds_ratio....fisher_one_tailed.estimate

###Making a bubble plot 

results_table <- fishers_results_table %>%
  mutate(
    log2_odds_ratio = log2(odds_ratio....fisher_one_tailed.estimate),
    neg_log10_pval = -log10(p_val_one_sided), #Minus log10 transformation 
    significant = p_val_one_sided < 0.05 
  )

fold_enrichment_bubble_plot <- ggplot(results_table, aes(x= reorder(New_cellType, odds_ratio....fisher_one_tailed.estimate), y = log2_odds_ratio)) + geom_point(aes(size = neg_log10_pval, color = significant)) + scale_color_manual(values = c("FALSE" = "grey30", "TRUE" = "deeppink3")) + scale_size_continuous(range = c(1,10)) + coord_flip() + labs( x = "Cell Type", y = "Fold Enrichment", size = "-log10(p-value)", color = "Significant") + theme_minimal() + theme(axis.text.y = element_text(size=10), legend.position = "right", panel.background = element_rect(fill = "white", color = NA), plot.background = element_rect(fill = "white", color = NA)) 

ggsave("fold_enrichment_bubbleplot_ggplot.png", fold_enrichment_bubble_plot, height = 15, width = 15)

```

## Gene Enrichment Analysis on Protein-coding Genes Only

Look into removing non-protein coding genes - reduce noise NB: Currently there is poor annotation of protein coding genes; harder to interpret this will be more relevant later on - Leave it for later

Additionally, large presence of non-protein coding genes can introduce noise and reduce statistical accuracy - often are found to not be DE, inflates p-values from testing leading to an increase in false positives

```{r}
## Filtering cells - Keep only protein-coding 
all_genes <- unique(rownames(seurat_subset_cleaned))
View(all_genes)


#Will most likely need to use an external reference to map protein-coding genes to 
#Loading in Ensembl Biomart Mouse Protein Coding Genes
ensembl_geneset <- read.csv("~/Documents/sophie_tmp/mart_export_1.txt", header = TRUE, check.names = TRUE, sep = ",")
View(ensembl_geneset) #[1] 101,744 rows - duplicated entries of stable IDs due to multiple transcript variants

## Cleaning Ensembl dataset
#Removing the other columns apart from the 'Gene.stable.id' and 'Gene.name'
print(ensembl_geneset[,-2:-3:-4]) #Prints only the first and last column
ensembl_geneset_filtered <- ensembl_geneset[,-2:-4]
View(ensembl_geneset_filtered) #Now only includes the two columns we want 

print(sum(duplicated(ensembl_geneset_filtered$Gene.stable.ID == "TRUE"))) #[1] 101743 almost all are duplicated at least once 
print(length(unique(ensembl_geneset_filtered$Gene.stable.ID))) #[1] 21,748 - we should have this amount after filtering 

empty_gene_names <- (ensembl_geneset_filtered$Gene.name == "")
print(sum(empty_gene_names)) #[1] 116 missing gene names missing 


for (i in empty_gene_names) {
  i <- "EMPTY"
  ensembl_geneset_filtered$Gene.name[empty_gene_names] <- i 
  return (i)
}

ensembl_geneset_cleaned <- ensembl_geneset_filtered %>% 
  distinct(Gene.stable.ID, .keep_all = TRUE)

View(ensembl_geneset_cleaned) #Contains all 21,748 entries including those with the word EMPTY in them 



###Recovering Ensembl ID's from the original h5 files 
files <- list.files(path= 'GSE153162_RAW_No_KO/', pattern='.h5', full.names =TRUE)
test <- h5read(files[1], "/mm10/genes")
print(test) #Confirmed that the ENMUSG ID's are there 

extract_gene_info <- function(file) { 
  # First check file structure 
  h5_struct <- h5ls(file) 
  # Try to directly get data from first file to determine structure 
  if (any(grepl("genes", h5_struct$name))) {
    # Try common paths based on typical 10X structures 
    path_prefix <- if("/mm10" %in% h5_struct$group) "/mm10/" else "/" 
    # Extract IDs and names 
    ids <- h5read(file, paste0(path_prefix, "genes")) 
    names <- h5read(file, paste0(path_prefix, "gene_names")) 
    return(list(ids=ids, names=names)) 
    } else { 
      # For newer formats, try loading via Seurat 
      data <- Read10X_h5(file) 
      # Extract gene info from the loaded data 
      if (is.list(data) && "Gene Expression" %in% names(data)) { 
        matrix_data <- data[["Gene Expression"]] 
        } else { matrix_data <- data } # Return gene IDs from matrix 
      return(list(ids=rownames(matrix_data))) } } # Apply to first file as a test 
result <- extract_gene_info(files[1]) 
head(result$ids)
#Result list objects have a length of 27,998 which is the total number of genes found in the seurat_object

# Create empty lists to store results from all files
all_ids <- list()
all_names <- list()

# Process all files
for (i in 1:length(files)) {
  file <- files[i]
  cat("Processing file", i, "of", length(files), ":", basename(file), "\n")
  result <- extract_gene_info(file)
  all_ids[[i]] <- result$ids
  if (!is.null(result$names)) {
    all_names[[i]] <- result$names

  }

}

# Check if all files have the same gene IDs (they should if using the same genome)

same_ids <- length(unique(lapply(all_ids, function(x) length(x)))) == 1
if (same_ids) {
  cat("All files have the same number of genes\n")
  # Just use the first file's IDs and names
  ensembl_ids <- all_ids[[1]]
  if (length(all_names) > 0) {
    gene_names <- all_names[[1]]

    # Create a mapping data frame
    gene_mapping <- data.frame(
      ensembl_id = ensembl_ids,
      gene_name = gene_names,
      stringsAsFactors = FALSE
    )
    # View first few rows
    head(gene_mapping)
  } else {
    # If no names were found, just use IDs
    ensembl_ids
  }
} else {
  cat("Files have different numbers of genes - may need to find common genes\n")
  # You could find the intersection of IDs across all files if needed
}


View(gene_mapping)


##Now filter seurat object using their ENMUSG ID's witht he ENMUSG ID's in the 'protein coding dataframe' 

# 1. Filtering the gene_mapping dataset of the seurat objects using the ensembl dataset 
View(intersect(gene_mapping$ensembl_id, ensembl_geneset_cleaned$Gene.stable.ID)) #21,116 protein coding genes found in the original h5 files i.e., our scRNA-seq dataset

gene_mapping_filtered <- gene_mapping %>%
  filter(ensembl_id %in% ensembl_geneset_cleaned$Gene.stable.ID)
View(gene_mapping_filtered) #[1] Now only contains the 21,116 protein coding genes 


# 2. Filtering the genes in the seurat object to those in the gene_mapping_filtered 
seurat_subset_pc_only <- subset(seurat_subset_cleaned, features = gene_mapping_filtered$gene_name)
View(seurat_subset_pc_only) #Seurat object that only contains protein coding genes 

length(unique(rownames(seurat_subset_pc_only))) #[1] 21,104 genes now 

length(intersect(extracting_genes,  ensembl_geneset_cleaned$Gene.name)) #ALL MACROCEPHALY GENES ARE PROTEIN CODING 


```

### Re-adjusting Bonferroni Corrected Values in the DEG file - Identify upreg and downreg marker

```{r}
length(unique(find_DEGs$gene)) #16167
DEGs_Coding_Only <- find_DEGs[find_DEGs$gene %in% rownames(seurat_subset_pc_only), ] 
length(unique(DEGs_Coding_Only$gene)) #14786

#using equation: p_val_adj = p_val * number of comparisons
DEGs_Coding_Only$p_val_adj_updated <- p.adjust(DEGs_Coding_Only$p_val, method = "bonferroni")


#Now filtering upreg and downreg markers 
upreg_markers_updat <- DEGs_Coding_Only[DEGs_Coding_Only$avg_log2FC>0 & DEGs_Coding_Only$p_val_adj_updated<0.05, ]
downreg_markers_updat <- DEGs_Coding_Only[DEGs_Coding_Only$avg_log2FC<0 & DEGs_Coding_Only$p_val_adj_updated<0.05, ]


```

What I did before WHICH WAS WRONG

`DEGs_Coding_Only <- (find_DEGs)`

`DEGs_Coding_Only$p_val_adj_updated <- (DEGs_Coding_Only$p_val) * 21104`

NB: log2\>0 is quite stringent? so can always try log2\>0.25

### Gene Enrichment Analysis - Updated Upregulated Genes

```{r}

#the new upreg markers have 398 new DE entries 
macro_upreg_markers_updat <- upreg_markers_updat[upreg_markers_updat$gene %in% extracting_genes, ]
View(macro_upreg_markers_updat)
print(length(unique(macro_upreg_markers_updat$gene))) #[1] 159  - decreased by 2 


#All cell types 
cell_types <- unique(upreg_markers_updat$cluster)

#Total number of genes that were tested 
total_genes <- length(unique(rownames(seurat_subset_pc_only))) #21104 

#ALL UPREGULATED NON-MACRO GENES 
non_macro_upreg_markers_updat <- upreg_markers_updat[!upreg_markers_updat$gene %in% macro_upreg_markers_updat$gene, ]
View(non_macro_upreg_markers_updat)

#Create a results table 
fishers_results_table_upreg_2 <- data.frame(
  New_cellType = character(),
  odds_ratio = numeric(),
  p_val_one_sided <- numeric(),
  p_val_two_sided <- numeric(),
  stringsAsFactors = FALSE
)


for (cell_type in cell_types) {
  n1 <- sum(macro_upreg_markers_updat$cluster == cell_type)
  n2 <- sum(non_macro_upreg_markers_updat$cluster == cell_type)
  
  #To check that it has been calculated correctly 
  total_upreg_in_cell_type <- sum(upreg_markers_updat$cluster == cell_type)
  if (n1+n2 != total_upreg_in_cell_type) {
    warning(paste("Calculation mismatch for ", cell_type))
  } else {
    c("Correctly calculated for ", cell_type, "\n")
  }
  
  n3 <- (175 - n1)
  n4 <- (21104 - (n1 + n2 + n3)) #Changed to new total number of genes 
  
  contingency_table <- matrix(
  c(n1,n2,n3,n4), nrow =2)
  
  fisher_one_tailed <- fisher.test(contingency_table, alternative = "greater")
  fisher_two_tailed <- fisher.test(contingency_table, alternative = "two.sided")
  
  fishers_results_table_upreg_2 <- rbind(fishers_results_table_upreg_2, data.frame(
    New_cellType = cell_type,
    odds_ratio <- fisher_one_tailed$estimate,
    p_val_one_sided = fisher_one_tailed$p.value,
    p_val_two_sided = fisher_two_tailed$p.value
  ))
  
  cat("Processed:", cell_type, "- Odds Ratio:", round(fisher_one_tailed$estimate, 2), 
      "- P-value:", format.pval(fisher_one_tailed$p.value, digits = 3), "\n")
}

```

```{r}
write.csv(fishers_results_table_updat, "Fishers_One_and_Two_Tailed_Protein_Coding_Only_Results.csv", row.names = FALSE)
```

### Fold Enrichment Analysis - Updated Upregulated Genes

```{r}
#Performing log transformation (Log2) - i.e, up or down, for easier visualization especially because we are dealing with really small values
#Adding a log2(odds_ratio) column to the results table 
fishers_results_table_upreg_2$log2_odds_ratio <- log2(fishers_results_table_upreg_2$odds_ratio....fisher_one_tailed.estimate)


#Plotting a Heatmap 
fold_enrichment_heatmap <- ggplot(fishers_results_table_updat) + geom_tile(aes(x= New_cellType, y = factor(1), fill = log2_odds_ratio)) +  scale_fill_gradientn(colors = colorRampPalette(brewer.pal(5, "RdPu"))(100),
                      name = "Fold Enrichment") + theme_minimal()

ggsave("fold_enrichment_heatmap_pc_only_ggplot.png", fold_enrichment_heatmap, bg = "white", height = 15, width = 20)



###Making a bubble plot 

results_table_upreg_2 <- fishers_results_table_upreg_2 %>%
  mutate(
    log2_odds_ratio = log2(odds_ratio....fisher_one_tailed.estimate),
    neg_log10_pval = -log10(p_val_one_sided), #Minus log10 transformation 
    significant = p_val_one_sided < 0.05 
  )

fold_enrichment_bubble_plot <- ggplot(results_table_upreg_2, aes(x= reorder(New_cellType, odds_ratio....fisher_one_tailed.estimate), y = log2_odds_ratio)) + geom_point(aes(size = neg_log10_pval, color = significant)) + scale_color_manual(values = c("FALSE" = "grey30", "TRUE" = "deeppink3")) + scale_size_continuous(range = c(1,10)) + coord_flip() + labs( x = "Cell Type", y = "Fold Enrichment", size = "-log10(p-value)", color = "Significant") + theme_minimal() + theme(axis.text.y = element_text(size=10), legend.position = "right", panel.background = element_rect(fill = "white", color = NA), plot.background = element_rect(fill = "white", color = NA)) 

ggsave("fold_enrichment_bubbleplot_pc_only_CORRECTED_ggplot.png", fold_enrichment_bubble_plot, height = 15, width = 15)

```

```{r}
#Correcting Fisher p-value - Bonferroni 
fishers_results_table_upreg_2$p_val_adj_one_sided <- fishers_results_table_upreg_2$p_val_one_sided * 24 #There are 24 clusters 

#Plotting DotPlot with corrected p_val as significance 
results_table_upreg_2 <- fishers_results_table_upreg_2 %>%
  mutate(
    log2_odds_ratio = log2(odds_ratio....fisher_one_tailed.estimate),
    neg_log10_pval = -log10(p_val_one_sided), #Minus log10 transformation 
    significant = p_val_adj_one_sided < 0.05 
  )

fold_enrichment_bubble_plot <- ggplot(results_table_upreg_2, aes(x= reorder(New_cellType, odds_ratio....fisher_one_tailed.estimate), y = log2_odds_ratio)) + geom_point(aes(size = neg_log10_pval, color = significant)) + scale_color_manual(values = c("FALSE" = "grey30", "TRUE" = "deeppink3")) + scale_size_continuous(range = c(1,10)) + coord_flip() + labs( x = "Cell Type", y = "Fold Enrichment", size = "-log10(p-value)", color = "Significant") + theme_minimal() + theme(axis.text.y = element_text(size=10), legend.position = "right", panel.background = element_rect(fill = "white", color = NA), plot.background = element_rect(fill = "white", color = NA)) 

ggsave("fold_enrichment_UPREG_bubbleplot_pc_only_corrected_ggplot.png", fold_enrichment_bubble_plot, height = 15, width = 15)
```

##### Plotting a Fold-Change Correlation Heatmap - NEED TO EDIT NTO COMPLETE

```{r}
corr_matrix <- cor(as.matrix(results_table$log2_odds_ratio))
dimnames(corr_matrix) <- list(results_table$New_cellType)

```

### Gene Enrichment Analysis - Updated Downregulated Genes

```{r}
# As we have performed previously 
macro_downreg_markers_updat <- subset(downreg_markers_updat, downreg_markers_updat$gene %in% extracting_genes)

#Checking how many macro genes are downregulated 
length(unique(macro_downreg_markers_updat$gene)) #[1] 147 out of 175 


#Now to test if these are signficant 

#All cell types 
cell_types <- unique(downreg_markers_updat$cluster)
#Total number of genes that were tested 
total_genes <- length(unique(rownames(seurat_subset_pc_only))) #21104 

#ALL UPREGULATED NON-MACRO GENES 
non_macro_downreg_markers_updat <- downreg_markers_updat[!downreg_markers_updat$gene %in% macro_downreg_markers_updat$gene, ]
View(non_macro_downreg_markers_updat)

#Create a results table 
fishers_results_table_downreg <- data.frame(
  New_cellType = character(),
  odds_ratio = numeric(),
  p_val_one_sided <- numeric(),
  p_val_two_sided <- numeric(),
  stringsAsFactors = FALSE
)


for (cell_type in cell_types) {
  n1 <- sum(macro_downreg_markers_updat$cluster == cell_type)
  n2 <- sum(non_macro_downreg_markers_updat$cluster == cell_type)
  
  #To check that it has been calculated correctly 
  total_downreg_in_cell_type <- sum(downreg_markers_updat$cluster == cell_type)
  if (n1+n2 != total_downreg_in_cell_type) {
    warning(paste("Calculation mismatch for ", cell_type))
  } else {
    c("Correctly calculated for ", cell_type, "\n")
  }
  
  n3 <- (175 - n1)
  n4 <- (21104 - (n1 + n2 + n3)) #Changed to new total number of genes 
  
  contingency_table <- matrix(
  c(n1,n2,n3,n4), nrow =2)
  
  fisher_one_tailed <- fisher.test(contingency_table, alternative = "greater")
  fisher_two_tailed <- fisher.test(contingency_table, alternative = "two.sided")
  
  fishers_results_table_downreg <- rbind(fishers_results_table_downreg, data.frame(
    New_cellType = cell_type,
    odds_ratio <- fisher_one_tailed$estimate,
    p_val_one_sided = fisher_one_tailed$p.value,
    p_val_two_sided = fisher_two_tailed$p.value
  ))
  
  cat("Processed:", cell_type, "- Odds Ratio:", round(fisher_one_tailed$estimate, 2), 
      "- P-value:", format.pval(fisher_one_tailed$p.value, digits = 3), "\n")
}


```

```{r}
write.csv(fishers_results_table_downreg, "fishers_1+2_tailed_DOWNREG_pc_only.csv", row.names = FALSE)
```

### Fold Enrichment Analysis - Updated Downregulated Genes

```{r}
#Same as before: 
#Adding a log2(odds_ratio) column to the results table 
fishers_results_table_downreg$log2_odds_ratio <- log2(fishers_results_table_downreg$odds_ratio....fisher_one_tailed.estimate)
#Correcting Fisher p-value - Bonferroni 
fishers_results_table_downreg$p_val_adj_one_sided <- fishers_results_table_downreg$p_val_one_sided * 24 #There are 24 clusters 

#Plotting DotPlot with corrected p_val as significance 
results_table_downreg <- fishers_results_table_downreg %>%
  mutate(
    log2_odds_ratio = log2(odds_ratio....fisher_one_tailed.estimate),
    neg_log10_pval = -log10(p_val_one_sided), #Minus log10 transformation 
    significant = p_val_adj_one_sided < 0.05 
  )

fold_enrichment_bubble_plot <- ggplot(results_table_downreg, aes(x= reorder(New_cellType, odds_ratio....fisher_one_tailed.estimate), y = log2_odds_ratio)) + geom_point(aes(size = neg_log10_pval, color = significant)) + scale_color_manual(values = c("FALSE" = "grey30", "TRUE" = "deeppink3")) + scale_size_continuous(range = c(1,10)) + coord_flip() + labs( x = "Cell Type", y = "Fold Enrichment", size = "-log10(p-value)", color = "Significant") + theme_minimal() + theme(axis.text.y = element_text(size=10), legend.position = "right", panel.background = element_rect(fill = "white", color = NA), plot.background = element_rect(fill = "white", color = NA)) 

ggsave("fold_enrichment_DOWNREG_bubbleplot_pc_only_corrected_ggplot.png", fold_enrichment_bubble_plot, height = 15, width = 15)
```

## Investigating Expression Patterns of Significantly Up/Downregulated Genes Across Cell Types

We have seen that there are specific cell types that have genes that are significantly upregulated but we want to see if the expression patterns of these genes show any form of groupings or specificity to cell types

Note: The cell types that were found to have macro genes that wer signficantly upregulated macro genes were: astrocytes, apical progenitors, cyclial glial cells DP_CPN_1, DL_CPN, SCPN and Layer 6b

```{r}
print(results_table)
print(macro_upreg_markers_updat)

sig_cell_types <- subset(results_table, results_table$significant == "TRUE") #subsetting the results_table to include only statistically significant records, so we can narrow down the cell types 
print(sig_cell_types)

sign_upreg_macro_genes_by_cell_type <- macro_upreg_markers_updat[macro_upreg_markers_updat$cluster %in% sig_cell_types$New_cellType, ] #subsetting the overall upregulated macrocephaly DEGs list to just include those with the cell types identified as significant 
sign_upreg_macro_genes_by_cell_type

print(unique(sign_upreg_macro_genes_by_cell_type$cluster))
print(length(unique(sign_upreg_macro_genes_by_cell_type$gene))) #133 genes



avg_exp_sig_macro <-  AverageExpression(
  seurat_subset_pc_only, features = unique(sign_upreg_macro_genes_by_cell_type$gene), group.by = "New_cellType", slot = "data"
)
avg_exp_sig_macro
View(avg_exp_sig_macro)

avg_exp_sig_macro_mat <- as.matrix(avg_exp_sig_macro$RNA)

#Scaling the data to improve visualisation
avg_exp_sig_macro_mat_scaled <- t(scale(t(avg_exp_sig_macro_mat)))

```

### Generating general heatmap of all genes across all cell types

```{r}
avg_exp_sig_macro_heatmap <- pheatmap(avg_exp_sig_macro_mat_scaled, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = TRUE ,fontsize_row = 7, fontsize_col = 8, angle_col = 45, raster = FALSE, gaps_row = 20, height = 15, annotation_legend_param = list(title = "Average Expression Across Cell Types"),filename = "sig_upreg_macro_genes_across_all_cell_types.png")

print(avg_exp_sig_macro_heatmap)

```

### Generating separate heatmaps for each significant cell type across all cell types

```{r}
#NB: Maybe have a look into using Euclidean distance for clustering genes#################################

unique_clusters <- unique(sign_upreg_macro_genes_by_cell_type$cluster)
unique_clusters

for (i in unique_clusters) {
  sig_genes_in_cluster <- sign_upreg_macro_genes_by_cell_type$gene[sign_upreg_macro_genes_by_cell_type$cluster==i] #Subset the data frame to contain only the genes associated to the current cluster 'i'
  avg_exp_mat_subset <- avg_exp_sig_macro_mat[sig_genes_in_cluster,]
  avg_exp_mat_subset_scaled <- t(scale(t(avg_exp_mat_subset)))
  
  filename <- paste0("sig_upreg_macro_genes_", i, "_across_all_cell_types.png")
  
  avg_exp_subset_heatmap <- pheatmap(avg_exp_mat_subset_scaled, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = TRUE ,fontsize_row = 7, fontsize_col = 8, angle_col = 45, raster = FALSE, gaps_row = 20, height = 15, annotation_legend_param = list(title = "Average Expression Across Cell Types"), main = paste0("Genes Upregulated In ", i), filename = filename)
  
}




### Making another version where we don't cluster by cell types so the order the cell types stays the same 
for (i in unique_clusters) {
  sig_genes_in_cluster <- sign_upreg_macro_genes_by_cell_type$gene[sign_upreg_macro_genes_by_cell_type$cluster==i] #Subset the data frame to contain only the genes associated to the current cluster 'i'
  avg_exp_mat_subset <- avg_exp_sig_macro_mat[sig_genes_in_cluster,]
  avg_exp_mat_subset_scaled <- t(scale(t(avg_exp_mat_subset)))
  
  filename <- paste0("sig_upreg_macro_genes_", i, "_across_all_cell_types_not_clustering_by_cols.png")
  
  avg_exp_subset_heatmap <- pheatmap(avg_exp_mat_subset_scaled, color = colorRampPalette(brewer.pal(5, "RdPu"))(100), clustering_method = "complete", cluster_rows = TRUE, cluster_cols = FALSE ,fontsize_row = 7, fontsize_col = 8, angle_col = 45, raster = FALSE, gaps_row = 20, height = 15, annotation_legend_param = list(title = "Average Expression Across Cell Types"), main = paste0("Genes Upregulated In ", i), filename = filename)
  
}

```

## Gene Ontology (GO) Enrichment Analysis - Diving into the potential functional properties and groups within upregulated macrocephaly genes 

**Using the 'Gene-set enrichment (non-genetic)' Rmd by Andrew Pocklington and Nicholas Clifton**

For Gene Ontology Analysis, it is important to have the correct background annotation set - e.g., when looking at brain genes, if your background set is the whole genome, some genes might be falsely considered enriched as there is a higher abundance of those types of genes in the brain. For our initial GO analysis, we will use a similar and observe what GO terms are flagged. For this, our background set is the same as previous enrichment analysis tests i.e., the whole scRNA-seq dataset

-   Can use the `gprofiler2` package: *"A toolset for functional enrichment analysis, and visualization, gene/protein/SNP identifier conversion and mapping orthologous genes across species via 'g:Profiler'. The main tools are (1) 'g:GOSt' - functional enrichment analysis and visualization gene lists; (2)'g:Convert - gene/protein/transcript identifier conversion across various namespaces; (3) 'g:Orth' - orthology search across species ; (4) 'g:SNPense' - mapping SNP rs identifiers to chromosome positions, genes and variant effects.'*

Question: What types of functions are enriched in macrocephaly genes compared to other brain genes?

```{r}
install.packages("gprofiler2")
library(gprofiler2)
#gprofiler requires Ensembl Gene IDs as an input - Luckily we still have our original gene mapping that we used to restrict our original seurat object to protein-coding genes 
head(gene_mapping_filtered)


#Running a basic GO analysis test - all macrocephaly and all scRNA-seq; no upregulated or DEGs-specific analysis yet. 

GO_test_set <- gene_mapping_filtered[gene_mapping_filtered$gene_name %in% extracting_genes, ] #subset gene_mapping by gene names found in the macrocephaly geneset 
GO_bkg_set <- gene_mapping_filtered

test_GO_analysis <- gost(GO_test_set$ensembl_id, organism = "mmusculus", exclude_iea = TRUE, correction_method = "bonferroni", sources = c("GO", "KEGG"), custom_bg = GO_bkg_set$ensembl_id, significant = TRUE,)

gostplot(test_GO_analysis)

#Extract results as a data frame 
GO_terms_df <- test_GO_analysis$result
GO_terms_df <- as.data.frame(GO_terms_df) ## It's not coercingggggggggg ahhhhhhhh
sapply(GO_terms_df, class) #The "parents" column is a list 

#Flattening the "parents" column 
GO_terms_df$parents_str <- sapply(GO_terms_df$parents, function(x) paste(x, collapse = ","))
GO_terms_df$parents <- NULL

write.csv(GO_terms_df, "GO_terms_tester.csv")
```

Now that we have tested the GO analysis tools, we are going to apply the same process with the DEGs. Our test set will be the DEGs macrocephaly genes vs the background set of all DEGs (like we did for the Fisher's Enrichment Test)

### GO Enrichment Analysis - Upregulated Macrocephaly Genes

Question: Within the upregulated genes, what functions do significantly enriched macrocephaly genes possess compared to other upregulated genes?

```{r}
GO_test_set <- gene_mapping_filtered[gene_mapping_filtered$gene_name %in% macro_upreg_markers_updat$gene, ] #subset gene_mapping by gene names found in the upregulated macrocephaly geneset

GO_bkg_set <- subset(gene_mapping_filtered, gene_mapping_filtered$gene_name %in% upreg_markers_updat$gene) 



#### When comparing the number of unique gene names in the upreg_markers_updat df and the ones in GO_bkg_set, I found a 5 gene difference mostly likely due to the gene name being assigned to two or more IDs

table(duplicated(GO_bkg_set$gene_name)) #[1] TRUE - 5 

#To see which ones in particular duplicated

dup_gene_names <- GO_bkg_set$gene_name[duplicated(GO_bkg_set$gene_name)] #[1] "Umad1"   "U2af1l4" "Itgam"   "Map2k7"  "Pcdhga8"

dup_table <- GO_bkg_set[GO_bkg_set$gene_name %in% dup_gene_names, ]
dup_table #Can see which IDs are assigned to them 


#Not removing then - as they all have different ENMUSG, therefore are most likely unique genes

upreg_GO_analysis <- gost(GO_test_set$ensembl_id, organism = "mmusculus", exclude_iea = TRUE, correction_method = "bonferroni", sources = c("GO", "KEGG"), custom_bg = GO_bkg_set$ensembl_id, significant = TRUE,)

gostplot(upreg_GO_analysis)

#Extract results as a data frame 
GO_terms_df <- upreg_GO_analysis$result
GO_terms_df <- as.data.frame(GO_terms_df) ## It's not coercingggggggggg ahhhhhhhh
sapply(GO_terms_df, class) #The "parents" column is a list 

#Flattening the "parents" column 
GO_terms_df$parents_str <- sapply(GO_terms_df$parents, function(x) paste(x, collapse = ","))
GO_terms_df$parents <- NULL

write.csv(GO_terms_df, "GO_terms_DEGs.csv")
```

-   To get which genes in particular matched, need to add the evocodes argument in the gost function

    ```{r}
    upreg_GO_analysis <- gost(GO_test_set$ensembl_id, organism = "mmusculus", exclude_iea = TRUE, correction_method = "bonferroni", sources = c("GO", "KEGG"), custom_bg = GO_bkg_set$ensembl_id, significant = TRUE, evcodes = TRUE)

    gostplot(upreg_GO_analysis)

    #Extract results as a data frame 
    GO_terms_df <- upreg_GO_analysis$result
    GO_terms_df <- as.data.frame(GO_terms_df) 
    sapply(GO_terms_df, class) 

    #Flattening the "parents" column 
    GO_terms_df$parents_str <- sapply(GO_terms_df$parents, function(x) paste(x, collapse = ","))
    GO_terms_df$parents <- NULL

    write.csv(GO_terms_df, "GO_terms_DEGs_with_genes.csv")
    ```

### Functional Clustering of GO Terms - Semantic Similarity

Semantic Similarity: Comparison and clustering of GO terms based on their relationship in the GO hierarchy, using metrics like path length, information content, or the lowest common ancestor

For this, we can use the Bioconductor package, `simplifyEnrichment`

```{r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("simplifyEnrichment")
library(simplifyEnrichment)



BiocManager::install("org.Hs.eg.db") #Installing this package (human genome annotation package?) as I was getting an erro when I tried to use simplifyEnrichment 

```

##### Performing Similarity Searching with original tester dataset 

```{r}

GO_terms_tester <- read.csv("GO_terms_tester.csv")
head(GO_terms_tester) #
GO_terms_tester_IDs <- GO_terms_tester$term_id
head(GO_terms_tester_IDs)

GO_similarity_tester <- GO_similarity(GO_terms_tester_IDs, ont = "BP")
simplifyGO(GO_similarity_tester)
```

```{r}

GO_terms_genes <- read.csv("GO_terms_DEGs_with_genes.csv")
head(GO_terms_genes) #
GO_terms_genes_IDs <- GO_terms_genes$term_id
head(GO_terms_genes_IDs)

GO_similarity_tester <- GO_similarity(GO_terms_genes_IDs, ont = "BP")
simplifyGO(GO_similarity_tester)


```

```{r}
#Can use the ouput of GOsimilarity (matrix) to perform hierarchical clustering 
ht_clusters(GO_similarity_tester, cl=binary_cut(GO_similarity_tester), order_by_size = TRUE)
cluster_terms_mat <- cluster_terms(GO_similarity_tester, method = "binary_cut")

str(cluster_terms_mat) #The 'names' i.e., the GO terms are missing so we need to manually reassign them

names(cluster_terms_mat) <- rownames(GO_similarity_tester)
str(cluster_terms_mat)

```

```{r}
#Mapping GO terms back to genes
#using the 'intersection' column in the GO_df which contains all the matched genes 

#The intersection column has multiple ensembl IDs for each entry separated by commas so we need to split it into individual entries 

GO_terms_df$intersection <- strsplit(GO_terms_df$intersection, ",") #Now they are individual entries 

GO_cluster_genes <- lapply(names(cluster_terms_mat), function(cluster_term_ids) {
  unique(unlist(GO_terms_df$intersection[GO_terms_df$term_id %in% cluster_term_ids]))
})


```

### Functional Cluster Enrichment per Cell Type

We now want to see if these functional groups are significantly enriched in specific cells i.e., is the GO cluster enriched in the upregulated genes of a particular cell type

```{r}
GO_fishers_results <- list()

for (cell_type in cell_types) {
  upreg_genes <- upreg_markers_updat$gene[upreg_markers_updat$cluster == cell_type]
  non_upreg_genes <- setdiff(rownames(seurat_subset_pc_only), upreg_genes)
  
  #Need to convert the gene names to ensembl ids - GO clusters use ensembl ids
  upreg_ensembl <- gene_mapping_filtered%>% 
    filter(gene_name %in% upreg_genes) %>%
    pull(ensembl_id)
  
  non_upreg_ensembl <- gene_mapping_filtered %>% 
    filter(gene_name %in% non_upreg_genes) %>%
    pull(ensembl_id)
  
  for (i in seq_along(GO_cluster_genes)) {
    cluster_genes <- GO_cluster_genes[[i]]

    n1 <- length(intersect(cluster_genes, upreg_ensembl)) # in GO cluster & upregulated
    n2 <- length(intersect(cluster_genes, non_upreg_ensembl)) # in GO cluster & not upregulated
    n3 <- length(setdiff(upreg_ensembl, cluster_genes)) # upregulated but not in GO cluster
    n4 <- length(setdiff(non_upreg_ensembl, cluster_genes)) # not upregulated and not in GO cluster
    
    contingency_table <- matrix(c(n1, n2, n3, n4), nrow = 2)
    fisher_result <- fisher.test(contingency_table)
    
    # Store results
    GO_fishers_results[[length(GO_fishers_results) + 1]] <- data.frame(
      cell_type = cell_type,
      GO_cluster = i,
      odds_ratio = fisher_result$estimate,
      p_val = fisher_result$p.value,
      overlap_up = n1,
      overlap_non_up = n2
      )
    
    cat("Processed:", cell_type, "- GO cluster:", i,
        "- Odds Ratio:", round(fisher_result$estimate, 2),
        "- P-value:", format.pval(fisher_result$p.value, digits = 3), "\n")
  }
}

# Combine all results into one data frame
GO_fishers_results_df <- do.call(rbind, GO_fishers_results)
# Adjust p-values
GO_fishers_results_df$p_val_adj <- p.adjust(GO_fishers_results_df$p_val, method = "bonferroni")

```

Next Question: Is the GO cluster more frequently enriched in macrocephaly cell types than in others?

-   simplfyEnrichment does not take into enrichment signal strength - may miss biologically significant results. There are some better alternatives:

    -   GOSemSim

    -   clusterProfiler

#### clusterProfiler 

```{r}
BiocManager::install("clusterProfiler")
library("clusterProfiler")
```

```{r}


```

#### GOSemSim 

```{r}
BiocManager::install("GOSemSim")
library(GOSemSim)
```

```{r}

sim_matrix <- mgoSim(GO_terms_tester_IDs, GO_terms_tester_IDs, semData = godata(annoDb = "org.Hs.eg.db", ont = "BP"), measure = "Resnik", combine = "BMA") #Best match average method 





#For clustering of functional groups 
sim_matrix_dist <- 1- sim_matrix

#Hierarchical clustering 
hc <- hclust(as.dist(sim_matrix_dist), method = "ward.D2")
clusters <- cutree(hc, k=10) #k-means 10 for now 
```

##### Saving counts matrix 'data'

```{r}
################ Work on this 
dim(seurat_merged@assays$RNA@scale.data)
print(head(seurat_merged@assays$RNA@scale.data))

#Saving the scaled data too 
OMIM_genes_exp_scaled <- seurat_merged@assays$RNA@scale.data[extracting_genes,]
write.csv(OMIM_genes_exp_scaled, "OMIM_dat_macro_scaled_expression_data_mouse.csv")

```

```{r}
#Extracting expression data for further analysis 
OMIM_genes_exp <- seurat_merged@assays$RNA@data[extracting_genes,] #Scale data or just 'data'
head(OMIM_genes_exp)
str(OMIM_genes_exp)
typeof(OMIM_genes_exp)
subset(OMIM_genes_exp, rownames(OMIM_genes_exp)=="Nfia")
print(OMIM_genes_exp)

#Saving the expression data 
write.csv(OMIM_genes_exp, "OMIM_dat_macro_expression_data_mouse.csv")
```

```{r}
#Saving all expression data 
total_exp <- seurat_merged@assays$RNA@data
head(total_exp)
write.csv(as.matrix(total_exp[1, , drop=FALSE]), "Total_expression_data_mouse.csv")

```
